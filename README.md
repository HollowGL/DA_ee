# DA_ee
**清华大学电子系数据与算法 2023Spring**

# 总结

累积200次左右提交，最终得分92

|      |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 得分 |  10  |  10  |  10  |  10  |  5   |  9   |  8   |  10  |  10  |  10  |

\* oj5有8个ac，但是超过ddl，仅得5分

# 题目

## 1. 寻找等式三元组

### 问题描述

给定一个整数数组，假设为num，请找出数组中是否存在三个元素：num[i]，num[j]，num[k]，其中i，j，k互不相等，且它们满足num[i]-num[j]+num[k]==0；请你找出所有满足该条件，且不重复的三元组；

### ### 输入格式

输入分为两行，第一行为数组的长度n（3<=n<=10000），第二行为数组num的n个元素（元素的大小在[-106,106]）之间；

### 输出格式

输出为1行，为满足num[i]-num[j]+num[k]==0三元组的个数；

如果不存在满足条件的三元组，则输出0；

### 输入样例

```
4
-1 -1 -1 0
```

### 输出样例

```
1
```

### 提示

1. 数组的排序可以用sort函数
2. i，j，k的顺序任意，并不要求i<j<k；
3. 注意不能重复的要求，

我们以数组num=[-1, -1,-1,0]为列，其满足num[i]-num[j]+num[k]==0的所有组合为

num[0]-num[1]+num[3]=-1-(-1)+0=0;

num[0]-num[2]+num[3]=-1-(-1)+0=0;

num[1]-num[2]+num[3]=-1-(-1)+0=0;

num[1]-num[0]+num[3]=-1-(-1)+0=0;

但是这四个三元组均重复，为[-1,-1,0]，所以输出结果为1；



## 2. 计算平均成绩

### 问题描述

假设你帮一名老师整理N个同学的成绩（N<=200000）。老师经常会需要你统计某一序号段内同学的平均成绩（注意：序号从1到N，而不是从0开始），而且随着课程的进行，同学们的成绩会不断变化，偶尔还会有同学退课（退课的同学不会太多，总共不超过10人，一名同学退课后，序号排在其后面的同学依次向前前进一位）。请你设计合适的数据结构和算法，帮助老师统计平均成绩。

我们用“事件1”代表对某一同学的成绩进行改变，用“事件2”代表统计某一序号段内同学的平均成绩，用“事件3”代表某个同学退课。

### 输入格式

输入共M+2行

第1行输入两个整数N和M分别代表学生人数和指令数，且N<=200000, M<=1000000

第2行输入N个整数，分别代表序号从1到N的同学的成绩（为了方便，假设成绩已经做了处理，为分布在[-100,100]区间内的实数）

第3到M+2行每行代表一个事件，每行的第一个数i代表事件编号。如果i=1，代表发生事件1，那么其后面有两个数j和n，代表将序号为j的同学的成绩改为n；如果i=2，代表发生事件2，其后面有两个数j和k（j<=k），代表事件2，此时需要你输出序号从j到k的同学的平均成绩；如过i=3，代表发生事件3，其后面有一个数k，代表序号为k的同学退课，序号排在其之后的同学的序号依次减一。

 

### 输出格式

输出共M2行（M2代表事件2发生的次数），每一行依次输出事件2对应的平均成绩，需要保留三位小数

### 输入样例

```
4  5
1 2 3 4
2 1 3
1 2 -1
2 1 2
3 2
2 1 2
```

### 输出样例

```
2.000
0.000
2.000
```

### 提示

1.如果用数组记录每个同学的成绩，那么每次修改的复杂度为O(1)，但是计算平均成绩的平均复杂度为O(N)。可以考虑用树状数组来记录同学们的成绩，这样每次修改和计算的平均复杂度都为O(logN)。假设原本的数组为A，那么为了求和构建的树状数组C的示意图如下：

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2023/03/10/zbixtv.png)

图像中从上到下的连线代表上面的数由下面连线对应的数求和得到，比如C6 = C5+A6， C8 = C4 + C6 + C7 + A8，等等。

2.在树状数组中，需要定义一个预操作函数lowbit，代表一个数的二进制的最后一个1所表示的数值，比如12转化为二进制是1100，其最后一个1在从右往左数第三位，那么lowbit(12) = 100（二进制） = 4（十进制），类似的可以得到lowbit(8) = 8， lowbit(6) = 2等等。有了lowbit函数以后，树状数组中每个元素的含义可以很清晰地表示为

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2023/03/10/1.jpg)

比如，C[5] = A[5], C[6] = A[5]+A[6], C[8] = A[1]+A[2]+...+A[8]等等。

那么当需要求A的前N项和的时候，作为替代，我们可以改成求C对应项的和，具体来说，A[1]+A[2]+...+A[N] = C[N0]+C[N1]+...+C[Nm-1]，其中N0 = N，Ni+1=Ni-lowbit(i)，m为N的二进制表示中1的个数。例如，当N = 7时，N0 = 7， N1 = 7-liwbit(7) = 6，N2 = 6-lowbit(6) = 4，那么就有A[1]+..+A[7] = C[7]+C[6]+C[4]。这样的话，求和操作的复杂度就由原本的O(N)降低到O(log(N))。上述操作的正确性我们不做证明，请同学们自行思考。

3.当A中某个元素A[i]被修改时，C中所有包含A[i]的元素都需要进行相应的修改。请同学们自行思考C中有哪些元素需要被修改（### 提示：同样可以用lowbit函数来求）。这里举个例子，当A[5]加上某个数时，C[5]、C[6]、C[8]、C[16]...都需要加上相同的数，上面的几个数的下标对应的二进制表示分别为101、110、1000、10000、...。

4.退课的同学不超过10个，退课时可以不用重新生成数组，而是把退课同学的序号记录下来，并把退课的同学的成绩修改为0。注意之后的序号和平均成绩的计算都要根据退课同学的序号进行相应调整。

5.使用scanf、printf替代cin、cout更快



## 3. 密文破译

### 问题描述

小明是一个黑客，为了锻炼自己，他参加了一个密文破译大赛。在大赛中，他拿到了一段密文***a***和一小段明文***b***，主办方告诉他，密文和明文都是小写字母，并且密文***a***破译后的明文中包含了***b***，要求他破译出完整的明文。

为此，小明想先找到明文***b***被加密后的位置，他尝试在***a***中找到这样一段**子密文**，这段**子密文**中包含了***b\***中的所有字母，并且**尽可能的短**，以此作为突破点。为了节约时间，他使用了一次现场求助的机会，求助了一位幸运观众，而你就是那位幸运观众，请你帮帮他。

注意：***b***中的字母在**子密文**中**不需要**按顺序出现。如果一个字母在***b***中出现了多次，那他也需要在**子密文**中至少出现对应多的次数（可以比该字母在***b***中出现的次数多）。

### 输入格式

输入共2行，均为小写字母：

第1行输入一个长度为m的字符串，即为密文***a***，m<3e7；

第2行输入一个长度为n的字符串，即为明文***b***，n<12000。

### 输出格式

输出共1行：

如果能找到这样的子密文，则输出**第一个**满足要求的**最短子密文**，均为小写字母；

如果没能找到这样的子密文，则输出-1。

### 输入样例

```
//样例1
abcdadba
aab

//样例2
abcd
e
```

### 输出样例

```
//样例1
adba

//样例2
-1
```

### 提示

可以使用string来保存字符串。



## 4. 数据库查询系统压缩

### 问题描述

某数据库为提升搜索效率，对某一整型字段构建二叉搜索树(BST)。每个结点包含两个数据信息：1）结点的数据；2）该结点子树的元素数目。为了压缩搜索树规模，该数据库为每个结点增加一个字段，该字段用于存储中序遍历时在访问该结点之前访问的结点数据。在该改进下，被存储的结点如果为叶子结点，该结点在新树中将被删除，以提高存储效率。如果一个叶子结点无中序后继，则无需删除。

 

给定该BST的先序遍历（第二个字段未给出），请编写程序，输出经过压缩后新BST的先序遍历结果。

 

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2022/10/06/ixfefr.png)

### 输入格式

输入共两行：

第一行为一个int数据n，表示该BST的总结点个数。1<=n<=100000；

第二行为n个int数据，为该BST的先序遍历结果（保证顺序是正确的，并保证数据两两不同）。 每个数据的范围：0<=x<=1*107。

### 输出格式

输出共一行：

第一行为新BST的先序遍历结果，依序输出结点数据以及保存的其他结点数据（若没有则输出字符-）

### 输入样例

```
7
6 4 2 5 9 7 8
```

### 输出样例

```
6 5 4 2 9 8 7 -
```

### 提示

1. 需要从先序遍历构建二叉树，并对二叉树进行压缩。

2. 【具体存储规则】题目描述等价于如下表述：对任意结点v：(1) 如果其有左子树，则存储其左子树的最大值，保留该结点；（2）如果没有左子树但有右子树，则不存储任何值，保留该结点；（3）否则（为叶子结点时），如果有中序后继，则可以删除，反之则不存储任何值，保留该结点。

【举例】一些结点可能并未被删除，但你仍需将其记录在中序遍历中下一个结点的第二个字段上（对应规则1）。下面的例子中，尽管左图中结点(3,1)没有被删除，但是为了充分利用已经开辟的存储空间，其父结点仍需存储该节点的值。

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2022/10/18/1.png)

3. 注意不要输出多余空格。

4. 个别### 输入样例需要在压缩二叉树时具有O(1)的空间复杂度，请搜索相关算法实现

## 5. 双向最短路径问题

### 问题描述

最短路径问题考虑的是带权有向图中从源点出发到达汇点时的最小的路径权。现在我们研究一种双向的最短路径问题，假设有两条分别以源点S1和源点S2为起点的路径，如果它们的终点是同一汇点，则称这两条路径“会合”了，此时他们分别有各自的路径权，将两个路径权的和称为总路径权。以下图为例，选取S1=1，S2=4，此时存在可以“会合”的两条路径，例如1-3-5和4-2-5，他们的汇点均为5，总路径权为18。在本题中，我们允许源点和汇点为同一个点，例如选取S1=1，S2=5时，1和5-1也是两条“会合”了的路径，他们的汇点均为1，总路径权为10。而如果选取S1=1，S2=6，则不存在可以“会合”的两条路径。

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2022/10/21/xolrya.png)

现给定一张顶点数为N的带权有向图，将顶点标记为1,...,N，假设源点S1=1，请判断源点S2=2,…,N时是否存在可以“会合”的两条路径，如果存在，请给出最小的总路径权。

### 输入格式

第一行输入两个正整数N和M，分别为带权有向图的顶点数和边数，N不大于20000且不小于2，M不大于200000。

接下来的M行各输入三个正整数，分别为Ui、Vi和Wi，表示图中的第i条边从顶点Ui指向顶点Vi，权重为Wi，其中i=1,...,M，Ui、Vi均不大于N，Wi不大于10000。

### 输出格式

输出共1行，为N-1个整数，分别表示S2=2,...,N时总路径权的情况。如果在题目描述的条件下不存在可以“会合”的两条路径，则输出-1，否则输出总路径权的值，不同值之间以空格隔开。

### 输入样例

```
6 9
4 3 8
5 1 10
1 3 7
4 2 4
3 1 8
3 5 3
2 5 4
3 2 2
5 2 7
```

### 输出样例

```
9 7 13 10 -1
```

### 提示

1. 题目所给的有向图为稀疏图，可以据此优化图的存储以及最短路径的构造。

2. 题目所给的有向图为简单图，即没有自环和重边。

3. 尝试在所给图的基础上构造新图以寻求巧妙的解决方法。



## 6. 文件清理大师

### 问题描述

小E同学使用电脑的习惯很差，经常在微信、QQ、浏览器等各种渠道下载文件后把文件随意放到各种文件夹里，且命名也不够规范，这导致了相同文件会以不同的名字出现在不同的文件夹里，从而极大浪费了电脑的储存空间，幸运的是，尽管文件名字不尽相同，但相同文件的不同名字之间只会相差一个下划线或一个数字后缀，例如file、file1、fi_le、fi_le2、fi_l_e均可视为一个文件，同一文件的严格定义如下：

\- 如果文件名a和文件名b只相差一个"_"或只在末尾相差一个1~9的一位阿拉伯数字，则可将a和b视为等价，它们为同一种文件

\- 如果a和b、b和c均可视为等价，则a和c可视为等价，即a和c也为同一种文件

\- 一个等价集合中只包含一种文件，且对该集合中的任意一个文件a，总能找到另一个文件b和它等价

\- 分好等价集合之后，一个等价集合内的文件和其他集合内的任何文件都不等价

\- 必定能找到一种分配方式，使得所有关键词被分成一个或多个无交集的等价集合，并且此分配方案唯一

现在小E需要写一个代码，统计重复文件的情况，方便自己进行清理，请你帮助小E完成此任务，并统计这些文件重复的次数最大值

### 输入格式

第1行：正整数 n (0 < n < 500)，代表需要整理的文件夹个数；

第2行~第n+1行：由正整数m (0 < m < 100) 与m个文件名组成，不同文件名之间由空格分隔

 

输入数据满足以下要求：

\- 文件名只会由小写字母、"_"和阿拉伯数字组成，阿拉伯数字的范围为1~9且只可能出现在文件名最后一位

\- 每个文件名长度不超过100

\- 一种文件在同一个文件夹中最多出现一次

### 输出格式

输出一个整数，表示所有文件里重复次数的最大值，数据保证只有一个文件能达到该最大值

### 输入样例

```
4
2 file_test2 file2
2 autos_ave2 file_tes_t4
4 file_tes_t2 photo video autosave2
3 autosave file_test video2
```

### 输出样例

```
4
//出现最多的文件为{file_test2, file_tes_t4, file_tes_t2, file_test}，在四个文件夹中均出现
```

### 提示

可考虑使用unordered_map等数据结构



## 7. 聪明的会计

### 问题描述

N位公民（个人收入分别为x[0],x[1],…,x[N-1]）前去税务局排队缴个人所得税。税务局大厅内摆有M（M<N）张桌子，每张桌子前分别坐着一名收税官（税率分别为h[0],h[1],…,h[M-1]），此外还有一位会计负责统计赋税。从t=0时刻起，公民们依次排队进入大厅，并经过这M个收税官。在t=0时刻，第0名公民站在第0张桌子前，其余N-1名公民在大厅外等候，此时第0名公民按照税率h[0]，交h[0]*x[0]的所得税。因此t=0时，会计记录赋税总额为y[0]=h[0]*x[0]。在t=1时刻，第0名公民移动到第1名收税官面前，交h[1]*x[0]的所得税的同时，第1名公民紧随其后，在第0名收税官面前交h[0]*x[1]的所得税。因此t=1时，会计记录赋税总额为y[1]=h[1]*x[0]+h[0]*x[1]。以此类推，当t=M+N-2时，最后一位公民在最后一位收税官面前缴税。

问：假设会计只能看到任意t时刻的赋税总额y[t],0<=t<=M+N-2和所有的税率h[0],h[1],…,h[M-1]。那么，会计是否能据此计算出每位公民的收入x[0],x[1],…,x[N-1]？如果问题的解存在，请输出此解；如果不存在，请输出数字N。

### 输入格式

输入共三行。

第一行有两个正整数，分别为N和M，N的范围为[1000,100000]，M的范围为[100,50000]；

第二行有N+M-1个实数，代表序列y[t], 0<=t<=M+N-2，每个实数的范围为[1,2000000]；

第三行有M个实数，代表序列h[t]，0<=t<=M-1，每个实数的范围为[1,10]。

### 输出格式

输出共一行。若问题的解存在，依次输出x[t]，0<=t<=N-1共N个实数（保留四位小数，实数间用空格分隔）；若问题解不存在，输出N。

注意：正确结果的每个实数都恰好有四位小数（×10000后为整数）。

### 输入样例

```
7 3
3 1 16 10 27 14 28 9 20
3 1 4
```

### 输出样例

```
1.0000 0.0000 4.0000 2.0000 3.0000 1.0000 5.0000
```

### 提示

1. 解决该问题的一种简单的方式是直接求解线性方程组。需要注意：（1）需要确认解是否存在；（2）求解方程时会出现误差累积的现象，注意利用结果的特性避免。这种方法至少能通过8个样本点。
2. 解决该问题还能采用复杂度更低的方法。具体请参考https://cloud.tsinghua.edu.cn/d/c568ea33933d4ed7b57e/。

## 8. 大规模稀疏线性方程的迭代求解

### 问题描述

本题目标为求解大规模稀疏线性方程组：Ax = b，其中A是稀疏矩阵（在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵）。

本次实验中给出的矩阵 A 均为维数不小于 1000不大于55000 的非奇异方阵，解的准确程度由残差值 ||AX - b||2给出，要求残差值小于 0.1。

 

### 输入格式

第 1 行：两个整数，分别是矩阵 A 的行（列）数 m，矩阵 A 中非 0 值的个数 k（k不超过300000）；

第 2 行 —— 第 k+1 行：每一行代表矩阵 A 中的一个非 0 元素，包括两个整数和一个浮点数，分别代表该元素的 行号、列号、元素取值；

第 k+2 行 —— 第 k+m+1 行：每一行代表方程组中 b 的一个元素取值，按照在向量 b 中的顺序排列，为浮点数。

 

注：矩阵元素行列号均从 0 开始。

### 输出格式

共输出 m 行。

第 1 行 —— 第 m 行：每一行一个浮点数，依次代表解向量元素 xi，i=1, 2, ..., m。

### 输入样例

```
3 4    // A为3行3列矩阵，共有4个非0值
0 0 3.00    // 第0行第0列的值为3.00
1 1 4.00    // 第1行第1列的值为4.00
2 1 5.00    // 第2行第1列的值为5.00
2 2 6.66    // 第2行第2列的值为6.66
100.01    // b1值为100.01
0.55    // b2值为0.55
1.00    // b3值为1.00
```

### 输出样例

```
33.3367    // x1
0.1375    // x2
0.04692    // x3
```

### 提示

**1. 输出精度**

C++中将double型变量输出到标准输出流中默认保留6位精度，在实际运算中这样的精度可能无法满足需求，这时需要同学们显式提高变量输出到标准输出流的精度。

**2. 关于稀疏矩阵的操作**

如果想用二维数组通过本次实验是一定不行的，计算机中一般用三元组来表示稀疏矩阵中的非零元素，每个三元组存储的信息为（行数，列数，值），而稀疏矩阵则是由一系列三元组构成的表。

一般而言，我们存储这些三元组有两种方式：
    （1）三元组表：用线性表去串联这些三元组，将二维稀疏矩阵压缩为一维的链表，这种方式可以节省存储空间，但是这样以来我们对矩阵进行操作就变得比较困难了。
    （2）十字链表：为了更快速地实现矩阵各种操作，我们给每个非零元素节点再加两个指针（一个横着方向的，一个竖直方向的），这样的话我们可以既沿着列方向访问该元素，也可以沿着行方向，从而大大提高我们的效率。 这就是十字链表诞生的原因，从这里也可看出十字链表是以单链表为基础的。

本次实验推荐同学们使用十字链表实现稀疏矩阵的相关操作。

**3. 方程组解法**

同学们可选择Gauss–Seidel迭代等方法求解线性方程组。（本题中矩阵A的对角线元素均不为0）

**4. 数据读入与输出**

由于本题数据读写较多，scanf和printf可节省时间。

## 9. 寻找苹果

### 问题描述

从前，森林里有一只爱吃苹果的懒惰的熊猫。一场暴风雨后，所有的苹果都从树上掉了下来。因为熊猫不想失去任何一个苹果，所以他想找到一个既有苹果又能看到其它所有苹果的位置。由于这只熊猫非常懒惰，他不想使眼睛移动的范围太大。你需要帮他找到这样一个苹果的位置，在这个位置他能够看到所有的苹果，同时眼睛转动的角度尽可能的小。你可以假设所有的苹果都可以建模为二维点。

下图展示了一个苹果的位置，熊猫从这里可以用最小的眼睛转动角度来看到所有的苹果。

![img](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2023/05/15/convex.png)

### 输入格式

首先输入一个正整数*T (**T≤10)*，表示测试案例的数量。

每一个测试案例首先输入一个正整数*n (**1≤n≤**105)*，*n*表示苹果的数量；

接下来*n* 行，每行包含两个整数*x,y (**-**106**≤x,y≤**106)*，表示每个苹果的坐标；

在同一个坐标上可能有多个苹果。

### 输出格式

对于每个测试案例，输出每个案例的最小角度，结果保留7位小数。

 

### 输入样例

```
2
1
4 4
4
0 0
10 0
10 10
2 1
```

### 输出样例

```
0.0000000
45.0000000
```

### 提示

求出二维点集的凸包，在凸包的顶点能够以更小的角度观察到更多的点，计算出每个顶点的内角的角度并找出最小的角度。

计算点集的凸包可以使用Andrew算法。



## 10. 健康膳食计划

### 问题描述

孙鹏同学想要控制自己的体重，为此他决定制定一个健康膳食计划，其目标是在**保证身体必须的营养的前提下尽量少吃东西**，由于每天能买到的食物种类众多，每种食物含有的营养物质又各不相同，所以他想要利用计算机帮助自己规划每日健康食谱，请你用所学《数据与算法》的知识帮助孙鹏同学制定他的健康食谱。

### 输入格式

输入由三部分组成：

第1行前两个整数分别表示当日需要的营养物质种类数 ***N*** 和当日可以买到的食物种类数 ***M***，其中 1<=***N***<=16，16种营养物质分别用编号0~15表示；1<=***M***<=216=65536，后 ***M*** 个整数分别表示当日能买到的 ***M*** 种食物各自对应的营养物质种类的数量；

第2行为 ***N*** 个整数，表示当日需要的营养物质列表，按数字大小升序排列；

第3\~***M***+2行为每种食物自己含有的营养物质列表，按数字大小升序排列，且食物自身的序号按行数从上到下依次编为0\~***M*** - 1号，需要注意，食物中可能含有当日不需要的营养物质，对于此类营养物质可以摄入也可以不摄入。

### 输出格式

输出为1行，为当日计划吃的食物，用空格分隔，且按数字大小升序排列，如果没有合适的食谱，则输出-1，题目数据保证如果有解，则解是唯一的。

### 输入样例

```
3 3 1 1 2
1 4 6
1
4
4 6
```

### 输出样例

```
0 2
```

### 提示

采用动态规划方法求解，可以考虑采用位运算提升程序效率
